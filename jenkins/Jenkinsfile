//"Update the custom data proc image used in leo.  The name of the job contains the name of the dataproc image created. This job will fail if master of terra-docker has not been updated since the last run, as the git hash has not changed. This is a happy side-effect of the fact image names must be unique."

//populated by first step
def ArrayList<String> images = []
def shortHash = ""

def shouldAbortBuild = false
def LinkedHashMap<String, String> imageToParamMap = [:]
def branchName = "automated-custom-image-hash-update-"

def getShortHash(hash) {
  return hash.substring(0,7)
}

def boolean hasHashChanges(ArrayList<String> images) {
  def Set imagesChanged = []

  def String[] configPaths = readFile("jenkins/confLocations.txt").trim().split("\n")


  for (String configFile: configPaths) {

    println("in change detection loop, before bash. File: $configFile")
    def gitOutput = sh(
      script: "git diff HEAD~1..HEAD $configFile",
      returnStdout: true
    ).trim()

      println("in change detection loop, after bash: $gitOutput")

    for (String image: images) {

      if (gitOutput.contains(image)) {
        println("detected changed image for $image")
        imagesChanged.add(image)
      }
    }
  }

  return !imagesChanged.isEmpty()
}

//if an image is in imageNames but not the confFile, the returned version will be an empty string
def LinkedHashMap<String,String> getVersionMap(ArrayList<String> imageNames, String configFile) {
  def LinkedHashMap<String,String> versionMap = [:]

  //for example, if $image is 'welder-server', this line would isolate 'a4f0e04' from the line below in a $configFile
  // welderDockerImage = "us.gcr.io/broad-dsp-gcr-public/welder-server:a4f0e04"
  for (String image: imageNames) {
    def version = sh(
      script: "cat $configFile | grep $image | tr ':' '\n' | tail -1 | tr -d '\"' ",
      returnStdout: true
    ).trim()

    versionMap[image] = version
  }

  return versionMap
}

pipeline {
  agent { label 'node210' }

  options {
    //we don't want to be building more than one PR's changes at once, we will queue them instead
    disableConcurrentBuilds()
  }

  triggers {
    // leaving the string empty causes it to trigger off pushes/PRs to the specified branch
    pollSCM("")
    //dataproc images expire every 60 days
    cron("0 0 */59 * *")
  }

  parameters {
    string(name: "IMAGE_BASE_NAME", defaultValue: "custom-leo-image",
          description: "The name to give the custom dataproc image. This will be appended with an hypen and the short version of the commit hash (first 7 characters).")
    booleanParam(name: "useCustomImages", defaultValue: false)
    string(name: "GOOGLE_PROJECT", defaultValue: "broad-dsp-gcr-public",
          description: "The google project to use")
    string(name: "BUCKET_NAME", defaultValue: "gs://leo-dataproc-image",
          description: "The bucket where the image will be stored")
    string(name: "terra_jupyter_base", defaultValue: "0.0.1")
    string(name: "terra_jupyter_hail", defaultValue: "0.0.1",
          description: "Is not currently baked into the image, but is here for future functionality")
    string(name: "terra_jupyter_r", defaultValue: "0.0.3")
    string(name: "terra_jupyter_python", defaultValue: "0.0.1")
    string(name: "terra_jupyter_bioconductor", defaultValue: "0.0.2",
          description: "Is not currently baked into the image, but is here for future functionality")
    string(name: "leonardo_jupyter", defaultValue: "5c51ce6935da",
          description: "The tag of the jupyter image to pull in docker image build. Used in the prepare script.")
    string(name: "welder_server", defaultValue: "latest",
          description: "The tag of the welder image to pull in docker image build. Used in the prepare script.")
    string(name: "openidc_proxy", defaultValue: "2.3.1_2",
          description:"The tag of the openidc proxy image to pull in docker image build. Used in the prepare script.")
  }

  stages {
    stage('Terra docker image scan') {
      steps {
        git credentialsId: 'jenkins-ssh-github', url: 'git@github.com:DataBiosphere/terra-docker.git', branch: 'master'

        script {
          def temp = readFile("jenkins/imageDirs.txt").trim().split("\n")
          images = new ArrayList<String>(Arrays.asList(temp))

          //non terra-docker images
          images.add('leonardo-jupyter')
          images.add('welder-server')
          images.add('openidc-proxy')
        }
      }
    }

    stage('Leonardo Git') {
      steps {
        git credentialsId: 'jenkins-ssh-github', url: 'git@github.com:DataBiosphere/leonardo.git', branch: 'develop'
      }
    }

    //create short hash properties file
    stage('Get Short Hash') {
      steps {
        script {
          shortHash = getShortHash("${env.GIT_COMMIT}")
        }
      }
    }

    stage('Docker and Gcloud Auth') {
      steps {
        sh """
          sudo chown -R jenkins:jenkins /home/jenkins/.config
          docker run --rm  -v /etc/vault-token-dsde:/root/.vault-token:ro broadinstitute/dsde-toolbox:latest vault read --format=json secret/dsde/firecloud/common/image-build-account.json | jq .data > image-build-account.json
          gcloud auth activate-service-account --key-file=image-build-account.json
          gcloud auth configure-docker --quiet
        """
      }
    }

    stage ('Detect Hash Changes') {
      when { expression { useCustomImages.equals("false") } }
      steps {
        script {
          def boolean shouldUpdate = hasHashChanges(images)
          shouldAbortBuild = !shouldUpdate //set variable to control if future steps get run
          def versionMap = getVersionMap(images, "automation/src/test/resources/reference.conf")

          if (shouldUpdate) {
            for (String image: images) {
              if (image in versionMap.keySet() && !versionMap[image].isEmpty()) { //the version could be empty if the image from terra-docker is not in a leo conf yet
                version = versionMap[image]
                println("using version $version for $image in this build of custom dataproc image")

                sh """
                  sed -i "s/$image.*/$image:$version\\"/" jenkins/dataproc-custom-images/prepare-custom-leonardo-jupyter-dataproc-image.sh
                """
              }
            }
          }
        }

        sh """
          echo 'printing changed config'
          cat jenkins/dataproc-custom-images/prepare-custom-leonardo-jupyter-dataproc-image.sh
          git diff jenkins/dataproc-custom-images/prepare-custom-leonardo-jupyter-dataproc-image.sh
        """
      }
    }

    stage ('Use manually specified hashes') {
      when { expression { useCustomImages.equals("true") } }

      steps {
        script {
          for(String image: images) {
            def varName = image.replace("-","_") //needed because the env vars use _ in place of the - in the image name due to bash restrictions

            //here we take advantage of the fact that the image names and jenkins version env variables have the same name to retrieve the versions
            version = sh(
              script: """
                eval "echo \$$varName"
              """,
              returnStdout: true
            ).trim()

            println("Manually replacing line with $image with $image:$version")

            sh (
              script: """
                sed -i "s/$image.*/$image:$version\\"/" jenkins/dataproc-custom-images/prepare-custom-leonardo-jupyter-dataproc-image.sh
              """
            )

            //will print any changed lines via git diff
            sh(
              script: "cat jenkins/dataproc-custom-images/prepare-custom-leonardo-jupyter-dataproc-image.sh; git diff jenkins/dataproc-custom-images/prepare-custom-leonardo-jupyter-dataproc-image.sh"
            )
          }
        }
      }
    }

      stage('Run build script') {
        when { expression { !shouldAbortBuild } }
        steps {
          sh """
            git submodule init && git submodule update
            cd jenkins/dataproc-custom-images/dataproc-custom-images
            python generate_custom_image.py \
              --image-name "$IMAGE_BASE_NAME-$shortHash" \
              --dataproc-version "1.2.79-debian9" \
              --customization-script ../prepare-custom-leonardo-jupyter-dataproc-image.sh \
              --zone us-central1-a \
              --gcs-bucket $BUCKET_NAME \
              --project-id=$GOOGLE_PROJECT \
              --disk-size=30
          """
        }
      }

      stage('Update custom leo image in conf') {
        when { expression { !shouldAbortBuild } }
        steps {
          script {

            def String[] configPaths = readFile("jenkins/confLocations.txt").trim().split("\n")
            for (String configFile: configPaths) {
              sh (
                  script: """
                    sed -i "s/$IMAGE_BASE_NAME.*/$IMAGE_BASE_NAME-$shortHash\\"/" $configFile; git add $configFile || true; git diff $configFile
                  """
              )
            }
          }

          sshagent(['jenkins-ssh-github']) {
            sh """
              git checkout -b $branchName$shortHash
              git commit -m "automated custom image hash updates"
              git push origin $branchName$shortHash
            """
          }

        }
      }

      stage('Update Build Name') {
        when { expression { !shouldAbortBuild } }
        steps {
          script {
            currentBuild.displayName = "#${BUILD_NUMBER}: $IMAGE_BASE_NAME-$shortHash"
          }
        }
      }

      stage('Notify Slack') {
        when { expression { !shouldAbortBuild } }
        steps {
          slackSend(channel: '#dsp-callisto-internal', message: "Jenkins has successfully built a custom leo dataproc image with the name:  $IMAGE_BASE_NAME-$shortHash. \nIf you would like to merge it, click: https://github.com/DataBiosphere/leonardo/pull/new/$branchName$shortHash")
        }
      }

  }
}
