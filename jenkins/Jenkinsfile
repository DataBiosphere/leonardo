//"Update the custom data proc image used in leo.  The name of the job contains the name of the dataproc image created. This job will fail if master of terra-docker has not been updated since the last run, as the git hash has not changed. This is a happy side-effect of the fact image names must be unique."

//populated by first step
def ArrayList<String> images = []
def shortHash = ""

def shouldAbortBuild = false

def LinkedHashMap<String, String> imageToParamMap = [:]

def getShortHash(hash) {
  return hash.substring(0,7)
}

def boolean hasHashChanges(ArrayList<String> images) {
  def Set imagesChanged = []

  def String[] configPaths = readFile("jenkins/confLocations.txt").trim().split("\n")


  for (String configFile: configPaths) {

    println("in change detection loop, before bash. File: $configFile") 
    def gitOutput = sh(
      // script: "git diff HEAD~1..HEAD $configFile | grep $image",
      //TODO change to ~1
      script: "git diff HEAD~40..HEAD $configFile",
      returnStdout: true
    ).trim()

      println("in change detection loop, after bash: $gitOutput") 

    for (String image: images) {

      if (gitOutput.contains(image)) {
        println("detected changed image for $image")
        imagesChanged.add(image)
      }
    }
  }

  return !imagesChanged.isEmpty()
}

//if an image is in imageNames but not the confFile, the returned version will be an empty string
def LinkedHashMap<String,String> getVersionMap(ArrayList<String> imageNames, String configFile) {
  def LinkedHashMap<String,String> versionMap = [:]

  for (String image: imageNames) {
    def version = sh(
      script: "cat $configFile | grep $image | tr ':' '\n' | tail -1 | tr -d '\"' ",
      returnStdout: true
    ).trim()

    versionMap[image] = version
  }

  return versionMap
}

pipeline {
  agent { label 'node210' } 

  options { 
    //we don't want to be building more than one PR's changes at once, we will queue them instead
    disableConcurrentBuilds() 
  }

  triggers {
    // poll repo every 2 minute for changes
    pollSCM("")
    //dataproc images expire every 60 days
    cron("0 0 */59 * *")
  }

  parameters {
    string(name: "IMAGE_BASE_NAME", defaultValue: "custom-leo-image",
          description: "The name to give the custom dataproc image. This will be appended with an hypen and the short version of the commit hash (first 7 characters).")
    booleanParam(name: "useCustomImages", defaultValue: false)
    string(name: "GOOGLE_PROJECT", defaultValue: "broad-dsp-gcr-public",
          description: "The google project to use")
    string(name: "BUCKET_NAME", defaultValue: "gs://leo-dataproc-image",
          description: "The bucket where the image will be stored")
    string(name: "terra_jupyter_base", defaultValue: "0.0.1")
    string(name: "terra_jupyter_hail", defaultValue: "0.0.1")
    string(name: "terra_jupyter_r", defaultValue: "0.0.3")
    string(name: "terra_jupyter_python", defaultValue: "0.0.1")
    string(name: "terra_jupyter_bioconductor", defaultValue: "0.0.2")
    string(name: "leonardo_jupyter", defaultValue: "dev",
          description: "The tag of the jupyter image to pull in docker image build. Used in the prepare script.")
    string(name: "welder_server", defaultValue: "latest",
          description: "The tag of the welder image to pull in docker image build. Used in the prepare script.")
    string(name: "openidc_proxy", defaultValue: "2.3.1_2",
          description:"The tag of the openidc proxy image to pull in docker image build. Used in the prepare script.")
  }

  stages {
    stage('Terra docker image scan') {
      steps {
         git credentialsId: 'jenkins-ssh-github', url: 'git@github.com:DataBiosphere/terra-docker.git', branch: 'jc-jenkinsfile'

          script {
            def temp = readFile("jenkins/imageDirs.txt").trim().split("\n")
            images = new ArrayList<String>(Arrays.asList(temp))

            //non terra-docker images
            images.add('leonardo-jupyter')
            images.add('welder-server')
            images.add('openidc-proxy')
          }

      }
    }

    stage('Leonardo Git') {
      steps {
        git credentialsId: 'jenkins-ssh-github', url: 'git@github.com:DataBiosphere/leonardo.git', branch: 'jc-auto-build-dataproc'
      }
    }
        
    //create short hash properties file

    stage('Get Short Hash') {
      steps {
        script {
          shortHash = getShortHash("${env.GIT_COMMIT}")
        }
      }
    }

    stage('Docker and Gcloud Auth') {
      steps {
        sh """
          sudo chown -R jenkins:jenkins /home/jenkins/.config
          docker run --rm  -v /etc/vault-token-dsde:/root/.vault-token:ro broadinstitute/dsde-toolbox:latest vault read --format=json secret/dsde/firecloud/common/image-build-account.json | jq .data > image-build-account.json   
          gcloud auth activate-service-account --key-file=image-build-account.json
          gcloud auth configure-docker --quiet
        """
      }
    }

    stage ('Detect Hash Changes') {
      when { expression { useCustomImages.equals("false") } }
      steps {
        script {
          def boolean shouldUpdate = hasHashChanges(images)
          shouldAbortBuild = !shouldUpdate //set variable to control if future steps get run
          def versionMap = getVersionMap(images, "automation/src/test/resources/reference.conf")
        
          if (shouldUpdate) {

            for (String image: images) {
              if (image in versionMap.keySet() && !versionMap[image].isEmpty()) { //the version could be empty if the image from terra-docker is not in a leo conf yet
                version = versionMap[image]
                println("using version $version for $image in this build of custom dataproc image")

                sh """
                  sed -i "s/$image.*/$image:$version\\"/" jenkins/dataproc-custom-images/prepare-custom-leonardo-jupyter-dataproc-image.sh
                """
              }
            }
          }
        }

        sh """
          echo 'printing changed config'
          cat jenkins/dataproc-custom-images/prepare-custom-leonardo-jupyter-dataproc-image.sh
        """
      }
    }

    stage ('Use manually specified hashes') {
      when { expression { useCustomImages.equals("true") } }

      steps {
        script {
          for(String image: images) {
            def varName = image.replace("-","_") //needed because the env vars use _ in place of the - in the image name due to bash restrictions

            //here we take advantage of the fact that the image names and jenkins version env variables have the same name to retrieve the versions 
            version = sh(
              script: """ 
                eval "echo \$$varName" 
              """,
              returnStdout: true
            ).trim()

            println("Manually replacing line with $image with $image:$version")

            sh (
              script: """
                sed -i "s/$image.*/$image:$version\\"/" jenkins/dataproc-custom-images/prepare-custom-leonardo-jupyter-dataproc-image.sh
              """
            )

            sh(
              script: "cat jenkins/dataproc-custom-images/prepare-custom-leonardo-jupyter-dataproc-image.sh; git diff jenkins/dataproc-custom-images/prepare-custom-leonardo-jupyter-dataproc-image.sh"
            )
          }
        }
      }
    }
            
      stage('Run build script') {
        when { expression { !shouldAbortBuild } }
        steps {
          sh """
            git submodule init && git submodule update
            cd jenkins/dataproc-custom-images/dataproc-custom-images
            python generate_custom_image.py \
              --image-name "$IMAGE_BASE_NAME-$shortHash" \
              --dataproc-version "1.2.79-debian9" \
              --customization-script ../prepare-custom-leonardo-jupyter-dataproc-image.sh \
              --zone us-central1-a \
              --gcs-bucket $BUCKET_NAME \
              --project-id=$GOOGLE_PROJECT
          """
        }
      }

      stage('Update Build Name') {
        when { expression { !shouldAbortBuild } }
        steps {
          script {
            currentBuild.displayName = "#${BUILD_NUMBER}: $IMAGE_BASE_NAME-$shortHash"
          }
        }
      }

      stage('Notify Slack') {
        when { expression { !shouldAbortBuild } }
        steps {
          slackSend(channel: '#newrelictest', message: "Jenkins has successfully built a custom leo dataproc image with the name:  $IMAGE_BASE_NAME-$shortHash")
        }
      }
      
  }
}