// Update the custom data proc image used in leo.  The name of the job contains the name of the dataproc image created. This job will fail if master of terra-docker has not been updated since the last run, as the git hash has not changed. This is a happy side-effect of the fact image names must be unique.

// Currently, this is referenced in a jenkins job with the following configuration:
// Create a 'New Item' that is a Pipeline in Jenkins
// Specify Pipeline script from SCM with the scm for leo and the appropriate branch
// Script Path should be the location of this file relative to the repo root

// Constants
String REGION = "us-central1"
String ZONE = "${REGION}-a"
String GCE_BASE_IMAGE = "projects/debian-cloud/global/images/debian-9-stretch-v20200210"

// Variables populated by first step
ArrayList<String> dataprocImages = []
ArrayList<String> gceImages = []
Set<String> images = [] // Union of dataprocImages and gceImages
String imageID = ""
String customDataprocImageBaseName = ""
String customGceImageBaseName = ""
String prLink = ""

LinkedHashMap<String, String> versionMap = [:]

boolean shouldAbortBuild = false
LinkedHashMap<String, String> imageToParamMap = [:]
String branchName = "automated-custom-image-hash-update-"

String getShortHash(hash) {
    String shortHash = hash.substring(0,7)
    println("Short hash is $shortHash")
    return shortHash
}

boolean hasHashChanges(Set<String> images) {
    Set imagesChanged = []

    String[] configPaths = readFile("jenkins/confLocations.txt").trim().split("\n")
    for (String configFile: configPaths) {
        println("Checking config file '$configFile' for any hash changes...")
        def gitOutput = sh(
            script: "git diff HEAD~1..HEAD $configFile",
            returnStdout: true
        ).trim()

        println("git diff result: $gitOutput")

        for (String image: images) {
            if (gitOutput.contains(image)) {
                println("Detected changed image for $image.")
                imagesChanged.add(image)
            }
        }
    }

    return !imagesChanged.isEmpty()
}

// If an image is in imageNames but not the confFile, the returned version will be an empty string
LinkedHashMap<String,String> getVersionMap(Set<String> imageNames) {
    LinkedHashMap<String, String> tempVersionMap = [:]
    LinkedHashMap<String, String> finalVersionMap = [:]

    String[] configPaths = readFile("jenkins/confLocations.txt").trim().split("\n")
    for (String configFile: configPaths) {
        tempVersionMap = getVersionMap(imageNames, configFile)
        for (String image in tempVersionMap.keySet()) {
            if (finalVersionMap.keySet().contains(image) && !finalVersionMap[image].isEmpty()) {
                // there is a nonempty version, we don't do anything here
            } else {
                finalVersionMap[image] = tempVersionMap[image]
            }
        }
    }
    return finalVersionMap
}

LinkedHashMap<String,String> getVersionMap(Set<String> imageNames, String configFile) {
    LinkedHashMap<String,String> versionMap = [:]

    // For example, if $image is 'welder-server', this line would isolate 'a4f0e04' from the line below in a $configFile.
    // welderDockerImage = "us.gcr.io/broad-dsp-gcr-public/welder-server:a4f0e04"
    // The awk at the end ensures that the line can have comments or other whitespace after the terminating quote.
    // Escaping '$' inside the 'awk' command is to appease Jenkins.
    for (String image: imageNames) {
        def version = sh(
          script: "cat $configFile | grep $image | tr ':' '\n' | tail -1 | tr -d '\"' | awk '{print \$1}' ",
          returnStdout: true
        ).trim()

        versionMap[image] = version
    }

    return versionMap
}

String getChangeDescription(LinkedHashMap<String,String> versionMap) {
    String title = "[jenkins-generated-pr] Automated custom image hash update"
    String body = "$title\n These are the images that are baked into this custom image:\n"
    String version = ""
    println("version map in getChangeDescription: " + versionMap.toString())
    for (String image in versionMap.keySet()) {
        if (versionMap[image].isEmpty()) {
            continue;
        }
        version = versionMap[image]
        println("updating body with $image: $version")
        body = body + "\n- $image: $version"
    }

    return body
}

pipeline {
    agent { label 'node210' }

    options {
        // We don't want to be building more than one PR's changes at once, we will queue them instead
        disableConcurrentBuilds()
    }

    triggers {
        // Leaving the string empty causes it to trigger off pushes/PRs to the specified branch
        pollSCM("")
    }

    parameters {
        booleanParam(name: "generateDataprocImage", defaultValue: true)
        booleanParam(name: "generateGceImage", defaultValue: true)
        // TODO: Revert to official name
        string(name: "IMAGE_BASE_NAME", defaultValue: "custom-leo-kyuksel-test-image",
            description: "The name to give the custom dataproc image. This will be appended with a hyphen and the short version of the commit hash (first 7 characters).")
        booleanParam(name: "useCustomImageIdentifier", defaultValue: false)
        string(name: "custom_image_id", defaultValue: "sampleUniqueID",
            description: "Specify along with useCustomImageIdentifier to build the VM image with a specific name")
        string(name: "GOOGLE_PROJECT", defaultValue: "broad-dsp-gcr-public",
            description: "The google project to use")
        // TODO: Rename to the eventual one
        string(name: "dataprocImageBucket", defaultValue: "gs://test-leo-dataproc-image",
            description: "The path for the bucket where the custom Dataproc images will be stored")
        // TODO: Rename to the eventual one
        string(name: "gceImageBucket", defaultValue: "gs://test-leo-gce-image",
            description: "The path for the bucket where the custom GCE images will be stored")
        string(name: "dataproc_versions", defaultValue: "1.2.79-debian9 1.4.15-debian9",
            description: "A custom image will be build for each of these dataproc versions")
        booleanParam(name: "useCustomDockerImageVersions", defaultValue: false,
            description: "Check if you want to specify custom image versions below")
        string(name: "terra_jupyter_base", defaultValue: "0.0.6")
        string(name: "terra_jupyter_hail", defaultValue: "0.0.5")
        string(name: "terra_jupyter_r", defaultValue: "0.0.7")
        string(name: "terra_jupyter_python", defaultValue: "0.0.6")
        string(name: "terra_jupyter_bioconductor", defaultValue: "0.0.9")
        string(name: "terra_jupyter_gatk", defaultValue: "0.0.8")
        string(name: "anvil_rstudio_base", defaultValue: "0.0.2")
        string(name: "anvil_rstudio_bioconductor", defaultValue: "0.0.3")
        string(name: "leonardo_jupyter", defaultValue: "5c51ce6935da",
            description: "The tag of the jupyter image to pull in docker image build. Used in the prepare script.")
        string(name: "welder_server", defaultValue: "60e28bc",
            description: "The tag of the welder image to pull in docker image build. Used in the prepare script. Please note this default is possibly an old hash.")
        string(name: "openidc_proxy", defaultValue: "2.3.1_2",
            description:"The tag of the openidc proxy image to pull in docker image build. Used in the prepare script.")
    }

    stages {
        stage('Terra docker image scan') {
            steps {
                git credentialsId: 'jenkins-ssh-github', url: 'git@github.com:DataBiosphere/terra-docker.git', branch: 'ky_ia_1596_jenkinsify_gce_image_creation'

                script {
                    customDataprocImageBaseName = "${IMAGE_BASE_NAME}-dataproc"
                    customGceImageBaseName = "${IMAGE_BASE_NAME}-gce-debian9"
                    ArrayList<String> nonTerraDockerImages = [
                        'leonardo-jupyter', 'welder-server', 'openidc-proxy', 'anvil-rstudio-base', 'anvil-rstudio-bioconductor'
                    ]

                    String selectBuildableTerraDockerImagesQuery = "cat config/conf.json | jq -r '.image_data | .[] | select(.automated_flags.build == true)"

                    def terraDockerDataprocImageArray = sh(
                        script: "$selectBuildableTerraDockerImagesQuery | select(.automated_flags.include_in_custom_dataproc == true) | .name'",
                        returnStdout: true
                    ).trim().split("\n")
                    
                    def terraDockerGceImageArray = sh(
                        script: "$selectBuildableTerraDockerImagesQuery | select(.automated_flags.include_in_custom_gce == true) | .name'",
                        returnStdout: true
                    ).trim().split("\n")

                    dataprocImages = terraDockerDataprocImageArray + nonTerraDockerImages
                    gceImages = terraDockerGceImageArray + nonTerraDockerImages
                    images = dataprocImages + gceImages

                    println("dataprocImages: $dataprocImages")
                    println("gceImages: $gceImages")
                    println("images: $images")
                }
            }
        }

    stage('Leonardo Git') {
        steps {
            // TODO: switch 'branch' back to 'develop'
            git credentialsId: 'jenkins-ssh-github', url: 'git@github.com:DataBiosphere/leonardo.git', branch: 'ky_ia_1596_jenkinsify_gce_image_creation'
        }
    }

    // Create short hash properties file
    stage('Set image ID') {
        steps {
            script {
                if (useCustomImageIdentifier == "true") {
                    imageID = "$custom_image_id"
                } else {
                    imageID = getShortHash(sh(
                        script: "git rev-parse HEAD",
                        returnStdout: true
                    ))
                }

                String buildDisplayName = "#${BUILD_NUMBER}: $IMAGE_BASE_NAME"
                if (generateDataprocImage == "true") {
                    buildDisplayName += "-dataproc-$dataproc_versions"
                }
                if (generateGceImage == "true") {
                    buildDisplayName += "-gce-debian9"
                }

                currentBuild.displayName = "$buildDisplayName-$imageID"
            }
        }
    }

    stage('Docker and Gcloud Auth') {
        steps {
            sh """
                sudo chown -R jenkins:jenkins /home/jenkins/.config
                docker run --rm  -v /etc/vault-token-dsde:/root/.vault-token:ro broadinstitute/dsde-toolbox:latest vault read --format=json secret/dsde/firecloud/common/image-build-account.json | jq .data > image-build-account.json
                gcloud auth activate-service-account --key-file=image-build-account.json
                gcloud auth configure-docker --quiet
            """
        }
    }

    stage ('Detect Hash Changes') {
        when { expression { useCustomDockerImageVersions == "false" } }
            steps {
                script {
                    def shouldUpdate = hasHashChanges(images)
                    // Set variable to control if future steps get run
                    shouldAbortBuild = !shouldUpdate
                    versionMap = getVersionMap(images)

                    if (shouldUpdate) {
                        for (String image: images) {
                            // The version could be empty if the image from terra-docker is not in a leo conf yet.
                            if (image in versionMap.keySet() && !versionMap[image].isEmpty()) {
                                version = versionMap[image]

                                if (generateDataprocImage == "true" && dataprocImages.contains(image)) {
                                    println("Using version $version for $image in this build of custom Dataproc images")
                                    sh """
                                        sed -i "s/$image.*/$image:$version\\"/" jenkins/dataproc-custom-images/prepare-custom-leonardo-jupyter-dataproc-image.sh
                                    """
                                }

                                if (generateGceImage == "true" && gceImages.contains(image)) {
                                    println("Using version $version for $image in this build of custom GCE images")
                                    sh """
                                        sed -i "s/$image.*/$image:$version\\"/" jenkins/gce-custom-images/prepare_custom_leonardo_gce_image.sh
                                    """
                                }
                            }
                        }

                        if (generateDataprocImage == "true") {
                            sh """
                                printf 'Printing any changed versions in prepare-custom-leonardo-jupyter-dataproc-image.sh:\\n\\n'
                                git diff jenkins/dataproc-custom-images/prepare-custom-leonardo-jupyter-dataproc-image.sh
                            """
                        }

                        if (generateGceImage == "true") {
                            sh """
                                printf 'Printing any changed versions in prepare_custom_leonardo_gce_image.sh:\\n\\n'
                                git diff jenkins/gce-custom-images/prepare_custom_leonardo_gce_image.sh
                            """
                        }
                    }
                }
            }
    }

    stage ('Use manually specified hashes') {
        when { expression { useCustomDockerImageVersions == "true" } }
            steps {
                script {
                    for (String image: images) {
                        // Needed because the env vars use _ in place of the - in the image name due to bash restrictions
                        def varName = image.replace("-","_")

                        // Here we take advantage of the fact that the image names and jenkins version env variables
                        // have the same name to retrieve the versions
                        version = sh(
                            script: """
                                        eval "echo \$$varName"
                                    """,
                            returnStdout: true
                        ).trim()

                        println("Manually replacing line with $image with $image:$version...")

                        if (generateDataprocImage == "true" && dataprocImages.contains(image)) {
                            println("Using version $version for $image in this build of custom Dataproc images")
                            sh """
                                sed -i "s/$image.*/$image:$version\\"/" jenkins/dataproc-custom-images/prepare-custom-leonardo-jupyter-dataproc-image.sh
                            """
                        }

                        if (generateGceImage == "true" && gceImages.contains(image)) {
                            println("Using version $version for $image in this build of custom GCE images")
                            sh """
                                sed -i "s/$image.*/$image:$version\\"/" jenkins/gce-custom-images/prepare_custom_leonardo_gce_image.sh
                            """
                        }

                        versionMap[image] = version
                    }

                    if (generateDataprocImage == "true") {
                        sh """
                            printf 'Printing any changed versions in prepare-custom-leonardo-jupyter-dataproc-image.sh:\\n\\n'
                            git diff jenkins/dataproc-custom-images/prepare-custom-leonardo-jupyter-dataproc-image.sh
                        """
                    }

                    if (generateGceImage == "true") {
                        sh """
                            printf 'Printing any changed versions in prepare_custom_leonardo_gce_image.sh:\\n\\n'
                            git diff jenkins/gce-custom-images/prepare_custom_leonardo_gce_image.sh
                        """
                    }
                }
            }
    }

    stage('Run image generation scripts') {
        when { expression { !shouldAbortBuild } }
            // Fail the pipeline if any of the parallel branches (that build the Dataproc and GCE images) fails
            failFast true
            parallel {
                stage('Run Dataproc image generation script') {
                    when { expression { generateDataprocImage == "true" } }
                        steps {
                            sh """
                                   git submodule init && git submodule update
                                """

                            script {
                                for (String dp_version : dataproc_versions.trim().split(' ')) {
                                    def dp_version_formatted = dp_version.replace(".", "-")
                                    // Dataproc 1.2 is used for the legacy image and must have python 3.6 installed
                                    // Otherwise, a terra-docker image is used which must have python 3.7 installed
                                    def python_version = dp_version.startsWith("1.2") ? "3.6.8" : "3.7.4"
                                    println("Installing Python $python_version on Dataproc $dp_version...")
                                    // TODO: Uncomment out running of the script
                                    //                        sh(
                                    //                            script: """
                                    //                                sed -i 's/python_version=.*/python_version="$python_version"/' jenkins/dataproc-custom-images/prepare-custom-leonardo-jupyter-dataproc-image.sh
                                    //                                cat jenkins/dataproc-custom-images/prepare-custom-leonardo-jupyter-dataproc-image.sh
                                    //                                cd jenkins/dataproc-custom-images/dataproc-custom-images
                                    //                                python generate_custom_image.py \
                                    //                                    --image-name "$customDataprocImageBaseName-$dp_version_formatted-$imageID" \
                                    //                                    --dataproc-version "$dp_version" \
                                    //                                    --customization-script ../prepare-custom-leonardo-jupyter-dataproc-image.sh \
                                    //                                    --zone $ZONE \
                                    //                                    --gcs-bucket $dataprocImageBucket \
                                    //                                    --project-id=$GOOGLE_PROJECT \
                                    //                                    --disk-size=50
                                    //                            """
                                    //                        )
                                }
                            }
                        }
                }

                stage('Run GCE image generation script') {
                    when { expression { generateGceImage == "true" } }
                        steps {
                            sh """
                                    docker pull gcr.io/compute-image-tools/daisy:latest
                                """

                            script {
                                String daisyImage = "gcr.io/compute-image-tools/daisy:latest"
                                sh """
                                        # Create the Daisy scratch bucket if it doesn't exist. The Daisy workflow will clean it up at the end.
                                        gsutil ls $gceImageBucket || gsutil mb -p $GOOGLE_PROJECT -l $REGION $gceImageBucket

                                        docker pull $daisyImage
                                        docker run -i --rm -v ${WORKSPACE}/jenkins/gce-custom-images:/daisy_source_files \
                                            $daisyImage \
                                            -project $GOOGLE_PROJECT \
                                            -zone $ZONE \
                                            -gcs_path $gceImageBucket \
                                            -default_timeout 60m \
                                            -var:base_image $GCE_BASE_IMAGE \
                                            -var:output_image "${customGceImageBaseName}-${imageID}" \
                                            -var:installation_script_dir /daisy_source_files \
                                            -var:installation_script_name prepare_custom_leonardo_gce_image.sh \
                                            -var:cis_hardening_playbook_config cis_hardening_playbook_config.yml \
                                            -var:cis_hardening_playbook_requirements cis_hardening_playbook_requirements.yml \
                                            /daisy_source_files/leo_custom_gce_image.wf.json
                                        
                                        # Daisy doesn't clean it up all so we remove the bucket manually
                                        gsutil rm -r $gceImageBucket
                                    """
                            }
                        }
                }
            }
    }

//       stage('Update custom leo image in conf') {
//         when { expression { !shouldAbortBuild } }
//         steps {
//           script {
//             def String[] configPaths = readFile("jenkins/confLocations.txt").trim().split("\n")
//             for (String configFile: configPaths) {
//               for (String dp_version: dataproc_versions.trim().split(' ')) {
//                 def dp_version_formatted = dp_version.replace(".","-")
//                 sh(
//                     script: """
//                       sed -i "s/$customDataprocImageBaseName-$dp_version_formatted.*/$customDataprocImageBaseName-$dp_version_formatted-$imageID\\"/" $configFile; git add $configFile || true; git diff $configFile
//                     """
//                 )
//               }
//             }
//           }
//
//           sshagent(['jenkins-ssh-github']) {
//             sh """
//               git checkout -b $branchName$imageID
//               git commit -m "automated custom image hash updates"
//               git push origin $branchName$imageID
//             """
//           }
//
//         }
//       }
//
//       stage('Create PR') {
//         when { expression { !shouldAbortBuild } }
//         steps {
//           script {
//             def changeDescription = getChangeDescription(versionMap)
//             withCredentials([file(credentialsId: 'hub-token', variable: 'token')]) {
//               sh """
//                 docker pull us.gcr.io/broad-dsp-gcr-public/hub:1
//
//                 docker rm -f hub-runtime | true
//
//                 docker run -itd --name=hub-runtime -u root -v ${WORKSPACE}:/app/leo us.gcr.io/broad-dsp-gcr-public/hub:1
//
//                 docker cp \$token hub-runtime:/home/dsde-jenkins/.config/hub
//                 docker exec hub-runtime sudo chmod 777 /home/dsde-jenkins/.config/hub
//
//               """
//             }
//
//             prLink = sh(
//               script: "docker exec --user dsde-jenkins hub-runtime hub pull-request -b develop -m \"$changeDescription\"",
//               returnStdout: true
//             ).trim()
//
//             sh """
//               docker stop hub-runtime
//               docker rm -f hub-runtime | true
//             """
//           }
//         }
//       }
//
//       stage('Notify Slack') {
//         when { expression { !shouldAbortBuild } }
//         steps {
//           slackSend(channel: '#dsp-callisto-internal', message: "Jenkins has successfully built a custom leo dataproc images for dataproc versions $dataproc_versions with the name: $customDataprocImageBaseName-$imageID. \nIf you would like to check the status of the PR, click: $prLink")
//         }
//       }
//
  }
}
