// Update the custom data proc image used in leo.  The name of the job contains the name of the dataproc image created. This job will fail if master of terra-docker has not been updated since the last run, as the git hash has not changed. This is a happy side-effect of the fact image names must be unique.

// Currently, this is referenced in a jenkins job with the following configuration:
// Create a 'New Item' that is a Pipeline in Jenkins
// Specify Pipeline script from SCM with the scm for leo and the appropriate branch
// Script Path should be the location of this file relative to the repo root

// Populated by first step
ArrayList<String> dataprocImages = []
ArrayList<String> gceImages = []
Set<String> images = [] // Union of dataprocImages and gceImages
String imageID = ""
String prLink = ""

LinkedHashMap<String, String> versionMap = [:]

boolean shouldAbortBuild = false
LinkedHashMap<String, String> imageToParamMap = [:]
String branchName = "automated-custom-image-hash-update-"

String getShortHash(hash) {
    String shortHash = hash.substring(0,7)
    println("Short hash is $shortHash")
    return shortHash
}

boolean hasHashChanges(Set<String> images) {
    Set imagesChanged = []

    String[] configPaths = readFile("jenkins/confLocations.txt").trim().split("\n")
    for (String configFile: configPaths) {
        println("Checking config file '$configFile' for any hash changes...")
        def gitOutput = sh(
            script: "git diff HEAD~1..HEAD $configFile",
            returnStdout: true
        ).trim()

        println("git diff result: $gitOutput")

        for (String image: images) {
            if (gitOutput.contains(image)) {
                println("Detected changed image for $image.")
                imagesChanged.add(image)
            }
        }
    }

    return !imagesChanged.isEmpty()
}

// If an image is in imageNames but not the confFile, the returned version will be an empty string
LinkedHashMap<String,String> getVersionMap(Set<String> imageNames) {
    LinkedHashMap<String, String> tempVersionMap = [:]
    LinkedHashMap<String, String> finalVersionMap = [:]

    String[] configPaths = readFile("jenkins/confLocations.txt").trim().split("\n")
    for (String configFile: configPaths) {
        tempVersionMap = getVersionMap(imageNames, configFile)
        for (String image in tempVersionMap.keySet()) {
            if (finalVersionMap.keySet().contains(image) && !finalVersionMap[image].isEmpty()) {
                // there is a nonempty version, we don't do anything here
            } else {
                finalVersionMap[image] = tempVersionMap[image]
            }
        }
    }
    return finalVersionMap
}

LinkedHashMap<String,String> getVersionMap(Set<String> imageNames, String configFile) {
    LinkedHashMap<String,String> versionMap = [:]

    // For example, if $image is 'welder-server', this line would isolate 'a4f0e04' from the line below in a $configFile.
    // welderDockerImage = "us.gcr.io/broad-dsp-gcr-public/welder-server:a4f0e04"
    // The awk at the end ensures that the line can have comments or other whitespace after the terminating quote.
    // Escaping '$' inside the 'awk' command is to appease Jenkins.
    for (String image: imageNames) {
        def version = sh(
          script: "cat $configFile | grep $image | tr ':' '\n' | tail -1 | tr -d '\"' | awk '{print \$1}' ",
          returnStdout: true
        ).trim()

        versionMap[image] = version
    }

    return versionMap
}

String getChangeDescription(LinkedHashMap<String,String> versionMap) {
    String title = "[jenkins-generated-pr] Automated custom image hash update"
    String body = "$title\n These are the images that are baked into this custom image:\n"
    String version = ""
    println("version map in getChangeDescription: " + versionMap.toString())
    for (String image in versionMap.keySet()) {
        if (versionMap[image].isEmpty()) {
            continue;
        }
        version = versionMap[image]
        println("updating body with $image: $version")
        body = body + "\n- $image: $version"
    }

    return body
}

pipeline {
    agent { label 'node210' }

    options {
        // We don't want to be building more than one PR's changes at once, we will queue them instead
        disableConcurrentBuilds()
    }

    triggers {
        // Leaving the string empty causes it to trigger off pushes/PRs to the specified branch
        pollSCM("")
    }

    parameters {
        // TODO: Make `generateDataprocImage` default `true`
        booleanParam(name: "generateDataprocImage", defaultValue: true)
        booleanParam(name: "generateGceImage", defaultValue: true)
        string(name: "IMAGE_BASE_NAME", defaultValue: "custom-leo-image",
              description: "The name to give the custom dataproc image. This will be appended with a hyphen and the short version of the commit hash (first 7 characters).")
        booleanParam(name: "useCustomImageIdentifier", defaultValue: false)
        string(name: "custom_image_id", defaultValue: "sampleUniqueID",
              description: "Specify along with useCustomImageIdentifier to build the image with a specific name")
        booleanParam(name: "useCustomImages", defaultValue: false)
        string(name: "GOOGLE_PROJECT", defaultValue: "broad-dsp-gcr-public",
              description: "The google project to use")
        string(name: "BUCKET_NAME", defaultValue: "gs://leo-dataproc-image",
              description: "The bucket where the image will be stored")
        string(name: "dataproc_versions", defaultValue: "1.2.79-debian9 1.4.15-debian9",
              description: "A custom image will be build for each of these dataproc versions")
        string(name: "terra_jupyter_base", defaultValue: "0.0.6")
        string(name: "terra_jupyter_hail", defaultValue: "0.0.5")
        string(name: "terra_jupyter_r", defaultValue: "0.0.7")
        string(name: "terra_jupyter_python", defaultValue: "0.0.6")
        string(name: "terra_jupyter_bioconductor", defaultValue: "0.0.9")
        string(name: "terra_jupyter_gatk", defaultValue: "0.0.8")
        string(name: "anvil_rstudio_base", defaultValue: "0.0.2")
        string(name: "anvil_rstudio_bioconductor", defaultValue: "0.0.3")
        string(name: "leonardo_jupyter", defaultValue: "5c51ce6935da",
              description: "The tag of the jupyter image to pull in docker image build. Used in the prepare script.")
        string(name: "welder_server", defaultValue: "60e28bc",
              description: "The tag of the welder image to pull in docker image build. Used in the prepare script. Please note this default is possibly an old hash.")
        string(name: "openidc_proxy", defaultValue: "2.3.1_2",
              description:"The tag of the openidc proxy image to pull in docker image build. Used in the prepare script.")
    }

    stages {
        stage('Terra docker image scan') {
            steps {
                git credentialsId: 'jenkins-ssh-github', url: 'git@github.com:DataBiosphere/terra-docker.git', branch: 'ky_ia_1596_jenkinsify_gce_image_creation'

                script {
                    ArrayList<String> nonTerraDockerImages = [
                        'leonardo-jupyter', 'welder-server', 'openidc-proxy', 'anvil-rstudio-base', 'anvil-rstudio-bioconductor'
                    ]

                    String selectBuildableTerraDockerImagesQuery = "cat config/conf.json | jq -r '.image_data | .[] | select(.automated_flags.build == true)"

                    def terraDockerDataprocImageArray = sh(
                        script: "$selectBuildableTerraDockerImagesQuery | select(.automated_flags.include_in_custom_dataproc == true) | .name'",
                        returnStdout: true
                    ).trim().split("\n")
                    
                    def terraDockerGceImageArray = sh(
                        script: "$selectBuildableTerraDockerImagesQuery | select(.automated_flags.include_in_custom_gce == true) | .name'",
                        returnStdout: true
                    ).trim().split("\n")

                    dataprocImages = terraDockerDataprocImageArray + nonTerraDockerImages
                    gceImages = terraDockerGceImageArray + nonTerraDockerImages
                    images = dataprocImages + gceImages

                    println("dataprocImages: $dataprocImages")
                    println("gceImages: $gceImages")
                    println("images: $images")
                }
            }
        }

    stage('Leonardo Git') {
        steps {
            // TODO: switch 'branch' back to 'develop'
            git credentialsId: 'jenkins-ssh-github', url: 'git@github.com:DataBiosphere/leonardo.git', branch: 'ky_ia_1596_jenkinsify_gce_image_creation'
        }
    }

    // Create short hash properties file
    stage('Set image ID') {
        steps {
            script {
                if (useCustomImageIdentifier == "true") {
                    imageID = "$custom_image_id"
                } else {
                    imageID = getShortHash(sh(
                        script: "git rev-parse HEAD",
                        returnStdout: true
                    ))
                }

                String buildDisplayName = "#${BUILD_NUMBER}: $IMAGE_BASE_NAME"
                if (generateDataprocImage == "true") {
                    buildDisplayName += "-dataproc-$dataproc_versions"
                }
                if (generateGceImage == "true") {
                    buildDisplayName += "-gce-debian9"
                }

                currentBuild.displayName = "$buildDisplayName-$imageID"
            }
        }
    }

    stage('Docker and Gcloud Auth') {
        steps {
            sh """
                sudo chown -R jenkins:jenkins /home/jenkins/.config
                docker run --rm  -v /etc/vault-token-dsde:/root/.vault-token:ro broadinstitute/dsde-toolbox:latest vault read --format=json secret/dsde/firecloud/common/image-build-account.json | jq .data > image-build-account.json
                gcloud auth activate-service-account --key-file=image-build-account.json
                gcloud auth configure-docker --quiet
            """
        }
    }

    stage ('Detect Hash Changes') {
        when { expression { useCustomImages == "false" } }
            steps {
                script {
                    def shouldUpdate = hasHashChanges(images)
                    // Set variable to control if future steps get run
                    shouldAbortBuild = !shouldUpdate
                    versionMap = getVersionMap(images)

                    if (shouldUpdate) {
                        for (String image: images) {
                            // The version could be empty if the image from terra-docker is not in a leo conf yet.
                            if (image in versionMap.keySet() && !versionMap[image].isEmpty()) {
                                version = versionMap[image]

                                if (generateDataprocImage == "true" && dataprocImages.contains(image)) {
                                    println("Using version $version for $image in this build of custom Dataproc images")
                                    sh """
                                        sed -i "s/$image.*/$image:$version\\"/" jenkins/dataproc-custom-images/prepare-custom-leonardo-jupyter-dataproc-image.sh
                                    """
                                }

                                if (generateGceImage == "true" && gceImages.contains(image)) {
                                    println("Using version $version for $image in this build of custom GCE images")
                                    sh """
                                        sed -i "s/$image.*/$image:$version\\"/" jenkins/gce-custom-images/prepare_custom_leonardo_gce_image.sh
                                    """
                                }
                            }
                        }
                    }
                }

                sh """
                    printf 'Printing changed versions in prepare-custom-leonardo-jupyter-dataproc-image.sh (if any):\n\n'
                    git diff jenkins/dataproc-custom-images/prepare-custom-leonardo-jupyter-dataproc-image.sh
                    printf '\n\nPrinting changed versions in prepare_custom_leonardo_gce_image.sh (if any):\n\n'
                    git diff jenkins/gce-custom-images/prepare_custom_leonardo_gce_image.sh
                """
            }
    }

//     stage ('Use manually specified hashes') {
//       when { expression { useCustomImages == "true" } }
//       steps {
//         script {
//           for(String image: images) {
//             def varName = image.replace("-","_") //needed because the env vars use _ in place of the - in the image name due to bash restrictions
//
//             //here we take advantage of the fact that the image names and jenkins version env variables have the same name to retrieve the versions
//             version = sh(
//               script: """
//                 eval "echo \$$varName"
//               """,
//               returnStdout: true
//             ).trim()
//
//             println("Manually replacing line with $image with $image:$version")
//
//             sh (
//               script: """
//                 sed -i "s/$image.*/$image:$version\\"/" jenkins/dataproc-custom-images/prepare-custom-leonardo-jupyter-dataproc-image.sh
//               """
//             )
//
//             versionMap[image] = version
//
//             //will print any changed lines via git diff
//             sh(
//               script: "cat jenkins/dataproc-custom-images/prepare-custom-leonardo-jupyter-dataproc-image.sh; git diff jenkins/dataproc-custom-images/prepare-custom-leonardo-jupyter-dataproc-image.sh"
//             )
//           }
//         }
//       }
//     }
//
//       stage('Run build script') {
//         when { expression { !shouldAbortBuild } }
//         steps {
//           sh """
//               git submodule init && git submodule update
//           """
//           script {
//             for(String dp_version: dataproc_versions.trim().split(' ')) {
//               def dp_version_formatted = dp_version.replace(".","-")
//               // Dataproc 1.2 is used for the legacy image and must have python 3.6 installed
//               // Otherwise, a terra-docker image is used which must have python 3.7 installed
//               def python_version = dp_version.startsWith("1.2") ? "3.6.8" : "3.7.4"
//               println("Installing Python $python_version on Dataproc $dp_version")
//               sh (
//                 script: """
//                   sed -i 's/python_version=.*/python_version="$python_version"/' jenkins/dataproc-custom-images/prepare-custom-leonardo-jupyter-dataproc-image.sh
//                   cat jenkins/dataproc-custom-images/prepare-custom-leonardo-jupyter-dataproc-image.sh
//                   cd jenkins/dataproc-custom-images/dataproc-custom-images
//                   python generate_custom_image.py \
//                     --image-name "$IMAGE_BASE_NAME-$dp_version_formatted-$imageID" \
//                     --dataproc-version "$dp_version" \
//                     --customization-script ../prepare-custom-leonardo-jupyter-dataproc-image.sh \
//                     --zone us-central1-a \
//                     --gcs-bucket $BUCKET_NAME \
//                     --project-id=$GOOGLE_PROJECT \
//                     --disk-size=50
//                 """
//               )
//             }
//           }
//         }
//       }
//
//       stage('Update custom leo image in conf') {
//         when { expression { !shouldAbortBuild } }
//         steps {
//           script {
//             def String[] configPaths = readFile("jenkins/confLocations.txt").trim().split("\n")
//             for (String configFile: configPaths) {
//               for (String dp_version: dataproc_versions.trim().split(' ')) {
//                 def dp_version_formatted = dp_version.replace(".","-")
//                 sh (
//                     script: """
//                       sed -i "s/$IMAGE_BASE_NAME-$dp_version_formatted.*/$IMAGE_BASE_NAME-$dp_version_formatted-$imageID\\"/" $configFile; git add $configFile || true; git diff $configFile
//                     """
//                 )
//               }
//             }
//           }
//
//           sshagent(['jenkins-ssh-github']) {
//             sh """
//               git checkout -b $branchName$imageID
//               git commit -m "automated custom image hash updates"
//               git push origin $branchName$imageID
//             """
//           }
//
//         }
//       }
//
//       stage('Create PR') {
//         when { expression { !shouldAbortBuild } }
//         steps {
//           script {
//             def changeDescription = getChangeDescription(versionMap)
//             withCredentials([file(credentialsId: 'hub-token', variable: 'token')]) {
//               sh """
//                 docker pull us.gcr.io/broad-dsp-gcr-public/hub:1
//
//                 docker rm -f hub-runtime | true
//
//                 docker run -itd --name=hub-runtime -u root -v ${WORKSPACE}:/app/leo us.gcr.io/broad-dsp-gcr-public/hub:1
//
//                 docker cp \$token hub-runtime:/home/dsde-jenkins/.config/hub
//                 docker exec hub-runtime sudo chmod 777 /home/dsde-jenkins/.config/hub
//
//               """
//             }
//
//             prLink = sh(
//               script: "docker exec --user dsde-jenkins hub-runtime hub pull-request -b develop -m \"$changeDescription\"",
//               returnStdout: true
//             ).trim()
//
//             sh """
//               docker stop hub-runtime
//               docker rm -f hub-runtime | true
//             """
//           }
//         }
//       }
//
//       stage('Notify Slack') {
//         when { expression { !shouldAbortBuild } }
//         steps {
//           slackSend(channel: '#dsp-callisto-internal', message: "Jenkins has successfully built a custom leo dataproc images for dataproc versions $dataproc_versions with the name:  $IMAGE_BASE_NAME-$imageID. \nIf you would like to check the status of the PR, click: $prLink")
//         }
//       }
//
  }
}
