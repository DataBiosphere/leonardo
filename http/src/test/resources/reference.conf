# a test DB is required.  Here's an example command to run one locally

# docker run --name mysql-leonardo \
# -e MYSQL_ROOT_PASSWORD=leonardo-test \
# -e MYSQL_USER=leonardo-test \
# -e MYSQL_PASSWORD=leonardo-test \
# -e MYSQL_DATABASE=leotestdb \
# -d -p 3311:3306 mysql/mysql-server:5.6

application {
  applicationName = "leonardo"
  leoGoogleProject = "leo-project"
  leoServiceAccountJsonFile = "leo-account.json"
  leoServiceAccountEmail = "leo@leo.com"
}

groups {
  subEmail = "google@dev.test.firecloud.org"
  dataprocImageProjectGroupName = "dataproc-image-project-group"
  dataprocImageProjectGroupEmail = ${groups.dataprocImageProjectGroupName}"@test.firecloud.org"
}

image {
  welderImage = "testwelderrepo/test"
  jupyterImage =  "testjupyterrepo/test"
  proxyImage = "testproxyrepo/test"
}

mysql {
  profile = "slick.jdbc.MySQLProfile$"
  batchSize = 5000
  host = "localhost"
  port = 3311
  db {
    driver = "com.mysql.cj.jdbc.Driver"
    url = "jdbc:mysql://"${mysql.host}":"${mysql.port}"/leotestdb?createDatabaseIfNotExist=true&useSSL=false&rewriteBatchedStatements=true&nullNamePatternMatchesAll=true"
    user = "leonardo-test"
    password = "leonardo-test"
    connectionTimeout = "5 seconds"  // default of 1 sec sometimes too short for docker local mysql
  }
  concurrency = 20
}

pubsub {
  pubsubGoogleProject = "broad-dsde-dev"
  topicName = "leonardo-pubsub"
  queueSize = 100
}

clusterFiles {
  configFolderPath = "http/src/test/resources/"
  jupyterServerCrt = "test-server.crt"
  jupyterServerKey = "test-server.key"
  jupyterRootCaPem = "test-server.pem"
  jupyterRootCaKey = "test-server.key"
}

clusterResources {
  initActionsScript = "test-init-actions.sh"
  initVmScript = "init-vm.sh"
  jupyterDockerCompose = "test-jupyter-docker-compose.yaml"
  jupyterDockerComposeGce = "test-jupyter-docker-compose-gce.yaml"
  rstudioDockerCompose = "test-rstudio-docker-compose.yaml"
  proxyDockerCompose = "test-proxy-docker-compose.yaml"
  proxySiteConf = "test-site.conf"
  jupyterNotebookConfigUri = "jupyter_notebook_config.py"
  jupyterNotebookFrontendConfigUri = "notebook.json"
  welderDockerCompose = "test-welder-docker-compose.yaml"
}

sam {
  server = "https://sam.test.org:443"
}

proxy {
  proxyDomain = ".jupyter.firecloud.org"
  proxyPort = 8001
}

swagger {
  googleClientId = "test.apps.googleusercontent.com"
  realm = "broad-dsde-test"
}

monitor {
  pollPeriod = 1 second
  maxRetries = -1  # means retry forever
  recreateCluster = true
  statusTimeouts {
    creating = 5 seconds
    starting = 5 seconds
    stopping = 5 seconds
    deleting = 5 seconds
    updating = 5 seconds
  }
}

auth {
  providerClass = "org.broadinstitute.dsde.workbench.leonardo.auth.SamAuthProvider"
  providerConfig = {
    samServer = "https://sam.test.org:443"
    petTokenCacheEnabled = true
    petTokenCacheExpiryTime = "60 minutes"
    petTokenCacheMaxSize = 100
  }

  whitelistProviderConfig = {
    whitelist = ["user1@example.com"]
  }

  samAuthProviderConfig = {
    samServer = "https://sam.test.org:443"
    petTokenCacheEnabled = true
    petTokenCacheExpiryTime = 60 minutes
    petTokenCacheMaxSize = 100
    providerTimeout = 1 second
    notebookAuthCacheEnabled = true
    notebookAuthCacheMaxSize  = 100
    notebookAuthCacheExpiryTime = 60 minutes
  }

  alwaysYesProviderConfig = {
    CreateClusters = true
    GetClusterStatus = true
    ConnectToCluster = true
    SyncDataToCluster = true
    DeleteCluster = true
    StopStartCluster = true
  }

  alwaysNoProviderConfig = {
    CreateClusters = false
    GetClusterStatus = false
    ConnectToCluster = false
    SyncDataToCluster = false
    DeleteCluster = false
    StopStartCluster = false
  }

  readOnlyProviderConfig = {
    CreateClusters = false
    GetClusterStatus = true
    ConnectToCluster = false
    SyncDataToCluster = false
    DeleteCluster = false
    StopStartCluster = false
  }

  syncOnlyProviderConfig = {
    CreateClusters = false
    GetClusterStatus = true
    ConnectToCluster = false
    SyncDataToCluster = true
    DeleteCluster = false
    StopStartCluster = false
  }

  optimizedListClustersConfig = {
    canSeeClustersInAllProjects = false
    canSeeAllClustersIn = ["visible-project"]
    GetClusterStatus = true

    #don't care about these for this test
    CreateClusters = false
    ConnectToCluster = false
    SyncDataToCluster = false
    DeleteCluster = false
    StopStartCluster = false
  }
}

serviceAccounts {
  providerClass = "org.broadinstitute.dsde.workbench.leonardo.auth.MockPetsPerProjectServiceAccountProvider"
  providerConfig = {
    leoServiceAccountEmail = "leo@leo.loe"
    leoServiceAccountPemFile = "test.pem"
    providerTimeout = 1 second
  }
}

autoFreeze {
  enableAutoFreeze = true
  dateAccessedMonitorScheduler = 1 second
  autoFreezeAfter = 15 minutes
  autoFreezeCheckScheduler = 2 second
}

zombieClusterMonitor {
  enableZombieClusterMonitor = true
  pollPeriod = 1 second
  creationHangTolerance = 9 second
  concurrency = 100
}

clusterToolMonitor {
  pollPeriod = 1 second
}

clusterDnsCache {
  cacheExpiryTime = 2 seconds
  cacheMaxSize = 100
}

leoExecutionMode {
  backLeo = true
}
akka.ssl-config {
  trustManager = {
    stores = [
      {
        type = "PEM"
        path = "http/src/test/resources/test-rootCA.pem"
      }
    ]
  }
}
